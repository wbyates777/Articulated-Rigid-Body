/* BDynamics 20/02/2024

 $$$$$$$$$$$$$$$$$$$
 $   BDynamics.h   $
 $$$$$$$$$$$$$$$$$$$

 by W.B. Yates
 Copyright (c) W.B. Yates. All rights reserved.
 History:

*/


#include <iostream>

#define GLM_ENABLE_EXPERIMENTAL
// either
#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES
// or
//#define GLM_FORCE_INTRINSICS

#include <glm/glm.hpp>


#ifndef __BDYNAMICS_H__
#include "BDynamics.h"
#endif


void
example1( void ) 
// this example is taken from RBDL library https://github.com/rbdl/rbdl
// the output generated by RBDL is QDDot = { -2.58949553  5.06986357 -2.48036804 }
{
    
    BModel* model = NULL;
    
    unsigned int body_a_id, body_b_id, body_c_id;
    BBody body_a, body_b, body_c;
    BJoint joint_a, joint_b, joint_c;
    
    model = new BModel();
    
    model->gravity( BVector3 (0., -9.81, 0.) );
    
    body_a = BBody (1., BVector3 (0.5, 0., 0.0), BVector3 (1., 1., 1.));
    joint_a = BJoint(
                     BJoint::BRevolute,
                     BVector3 (0., 0., 1.)
                     );
    
    body_a_id = model->addBody(0, arb::Xtrans(BVector3(0., 0., 0.)), joint_a, body_a);
    
    body_b = BBody (1., BVector3 (0., 0.5, 0.), BVector3 (1., 1., 1.));
    joint_b = BJoint (
                      BJoint::BRevolute,
                      BVector3 (0., 0., 1.)
                      );
    
    body_b_id = model->addBody(body_a_id, arb::Xtrans(BVector3(1., 0., 0.)), joint_b, body_b);
    
    body_c = BBody (0., BVector3 (0.5, 0., 0.), BVector3 (1., 1., 1.));
    joint_c = BJoint (
                      BJoint::BRevolute,
                      BVector3 (0., 0., 1.)
                      );
    
    body_c_id = model->addBody(body_b_id, arb::Xtrans(BVector3(0., 1., 0.)), joint_c, body_c);
    

    BModelState qinput;
    
    qinput.q.resize(model->qsize(),1.0);
    qinput.qdot.resize(model->qdotsize(), 1.0);
    qinput.tau.resize(model->qdotsize(), 1.0);
    
    BDynamics dyn;
    dyn.forward(*model, qinput);
    
    std::cout << qinput.qddot << std::endl;
    
    
    delete model;
}

    
void
example2( void )
// Complex example to test code -- doesn't make physical sense
// the forward output generated by RBDL on this example is
// QDOT = { 0.00000621, -9.80999590, 0.00000644, 31.43004589, -0.74277671, 15.33985878, -65.28759632, 54.91808109, -40.79517561, 3.69334706, 9.57489516 }
{
    double massA = 100000000.0;
    std::vector<double> com_a = { 0.0, 0.0, 0.0 };
    std::vector<double> trans_a = { 0.0, 20.0, 0.0 };

    double massC = 100.0;
    std::vector<double> com_c = { 0.0, 0.0, 0.0 };
    std::vector<double> trans_c = { 0.0, 10.0, 0.0 };
    
    BModel* model = new BModel(15);
    
    model->gravity( BVector3(0.0, -9.81, 0.0));
    
    
    BJoint joint_a = BJoint( BJoint::BFloatingBase );
    BBody body_a = BBody(massA, glm::dvec3(com_a[0], com_a[1], com_a[2]), BVector3(10.0, 10.0, 10.0));
    int body_a_id = model->addBody(0, arb::Xtrans(BVector3(trans_a[0],trans_a[1],trans_a[2])), joint_a, body_a);

    BSpatialVector helical(0.25, 0.25, 0.25, 0.25, 0.25, 0.0); 
    BJoint joint_b = BJoint( helical );
    BBody body_b = BBody(5.0, glm::dvec3(0.0, 0.75, 0.0), BVector3(2.0, 2.0, 2.0));
    int body_b_id = model->addBody(body_a_id, arb::Xtrans(BVector3(1.0, 0.0, 0.0)), joint_b, body_b);
    
    BJoint joint_c = BJoint( BJoint::BSpherical ); 
    BBody body_c  = BBody(massC, BVector3(com_c[0], com_c[1], com_c[2]), BVector3(2.0, 2.0, 2.0));
    int body_c_id = model->addBody(body_b_id, arb::Xtrans(BVector3(trans_c[0], trans_c[1], trans_c[2])), joint_c, body_c);
    
    BJoint joint_d = BJoint( BJoint::BRevolute, BVector3(0.0, 0.0, 1.0));
    BBody body_d = BBody(10.0, BVector3 (0.5, 0.0, 0.0), BVector3(2.0, 2.0, 2.0));
    int   body_d_id = model->addBody(body_c_id, arb::Xtrans(BVector3(1.0, 1.0, 0.0)), joint_d, body_d);
    
    
    
    // one for each body (including 0 body)
    std::vector<BSpatialVector> f_ext(11);
    f_ext[0].set(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    f_ext[1].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[2].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[3].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[4].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[5].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[6].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    f_ext[7].set(0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    f_ext[8].set(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    f_ext[9].set(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    f_ext[10].set(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

    
    BModelState qinput;
    
    qinput.q.resize(model->qsize(),1.0);
    qinput.qdot.resize(model->qdotsize(), 1.0);
    qinput.tau.resize(model->qdotsize(), 0.0);
    
    BDynamics dyn;
    dyn.forward(*model, qinput, f_ext);
    
    std::cout << qinput.qddot << std::endl;

    delete model;
}


// Example 3 -- clarify interface
void
single_body( void ) 
{
   
    // note spatial vectors - (angular,linear) - a force or velocity
    BModel* model = new BModel;

    model->gravity( BVector3(0.0, -9.81, 0.0) );
    //model->gravity( BVector3(0.0, 0.0, 0.0) );
  
    // set up single body -- i.e. a spaceship 
    // floating base only used for first body in model.
    BBody spaceship = BBody(10.0,  B_ZERO_3, BVector3(1.0, 1.0, 1.0));
    BJoint joint = BJoint( BJoint::BFloatingBase );
    BBodyId spaceshipId = model->addBody(0, arb::Xtrans(B_ZERO_3), joint, spaceship);
    
    // control
 
   
    BModelState qinput;
    
    qinput.q.resize(model->qsize(),1.0);
    qinput.qdot.resize(model->qdotsize(), 1.0);
    qinput.tau.resize(model->qdotsize(), 0.0);
    
    BDynamics dyn;
    dyn.forward(*model, qinput);
    

    std::cout << "linear acceleration (" << qinput.qddot[0] << ", " << qinput.qddot[1] << ", " << qinput.qddot[2] << std::endl;
    std::cout << "angular acceleration (" << qinput.qddot[3] << ", " << qinput.qddot[4] << ", " << qinput.qddot[5] << std::endl;
    
    std::cout  << std::endl;
    
    delete model;

}

void
newton_euler( void ) 
// https://en.wikipedia.org/wiki/List_of_moments_of_inertia
// https://en.wikipedia.org/wiki/Newtonâ€“Euler_equations
// Featherstone, Section 2.14, eqn 2.71, page 36.
{
    // note spatial vectors - (angular, linear) - a force or velocity
 
    //
    // set up single body - a sphere -  
    //
    double mass = 100.0, radius = 0.5;
    BVector3 rotational_intertia = BVector3((2.0/5.0) * mass * (radius * radius)); 
    BVector3 com = BVector3(0.0); // centre of mass
    BBody sphere = BBody(10.0,  com, rotational_intertia);
    
    std::cout << "Sphere of mass " << mass << " and radius " << radius << std::endl;
    std::cout << "Rotational inertia \n" << sphere.inertia() << std::endl;
    std::cout  << std::endl;
    
    BSpatialInertia I = sphere.I();
    std::cout << "Spatial inertia \n" << (BSpatialMatrix) I << std::endl;
    
    
    //
    // Newton-Euler
    //
    BSpatialVector acc(0.0);
    BSpatialVector vel(0.0);
    acc[4] = -9.81; // gravity

    BSpatialVector force = I * acc + arb::crossf(vel, I * vel);
    
    std::cout  << "\n\nSpatial force " << std::endl;
    std::cout  << force << std::endl;
    std::cout  << std::endl;
}


int 
main()
{
    std::cout.precision(8);
    std::cout.setf( std::ios::fixed, std::ios::floatfield );
    
    // example1 is taken from RBDL library https://github.com/rbdl/rbdl
    // the output generated by RBDL is QDDot = { -2.58949553  5.06986357 -2.48036804 }
    example1();
    
    // the ForwardDynamics output generated by RBDL on this example is
    // QDDot = { 0.00000621, -9.80999590, 0.00000644, 31.43004589, -0.74277671, 15.33985878, -65.28759632, 54.91808109, -40.79517561, 3.69334706, 9.57489516 }
    // you should notice slight differences in the last decimal places
    example2();
    
    // Example 3 -- clarify interface
    newton_euler();
    
    // Example 4 -- clarify interface
    single_body();
}
